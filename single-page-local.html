<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activity Viewer</title>

    <!-- External Libraries -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fit-file-parser@2.0.8/dist/fit-parser.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 12px;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .activity-header {
            flex: 1;
            min-width: 300px;
        }

        .activity-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .activity-meta {
            color: #666;
            font-size: 13px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-card {
            background: white;
            padding: 12px 14px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }

        .stat-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 6px;
            letter-spacing: 0.3px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #333;
        }

        .stat-unit {
            font-size: 14px;
            color: #666;
            font-weight: 400;
            margin-left: 2px;
        }

        #map {
            height: 400px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            margin-bottom: 12px;
        }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .chart-card {
            background: white;
            padding: 14px 16px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }

        .chart-card h3 {
            font-size: 13px;
            margin-bottom: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .chart-wrapper {
            height: 180px;
            position: relative;
        }

        .description-card {
            background: white;
            padding: 14px 16px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            margin-bottom: 12px;
        }

        .description-card h3 {
            font-size: 13px;
            margin-bottom: 8px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .description-card p {
            line-height: 1.5;
            color: #666;
            white-space: pre-wrap;
            font-size: 14px;
        }

        .error {
            background: #fee;
            color: #c00;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .hidden {
            display: none;
        }

        .status {
            color: #666;
            font-size: 12px;
            padding: 8px 12px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .files-detected {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 12px;
        }

        .files-detected-label {
            font-weight: 600;
            color: #666;
        }

        .file-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }

        .file-item a {
            color: #fc4c02;
            text-decoration: none;
        }

        .file-item a:hover {
            text-decoration: underline;
        }

        .file-icon {
            font-size: 14px;
        }

        .unit-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .unit-toggle label {
            font-size: 12px;
            font-weight: 600;
            color: #666;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #fc4c02;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .unit-label {
            font-size: 12px;
            color: #666;
            min-width: 20px;
        }

        .media-thumbnails {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .media-thumbnail {
            width: 64px;
            height: 64px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .media-thumbnail:hover {
            border-color: #fc4c02;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 40px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
        }

        .modal-close:hover {
            color: #fc4c02;
        }

        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
        }

        .modal-nav:hover {
            background: rgba(252, 76, 2, 0.8);
        }

        .modal-prev {
            left: 20px;
        }

        .modal-next {
            right: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="status" id="status">Loading activity data...</div>

        <div id="error" class="error hidden"></div>

        <div id="activityContent" class="hidden">
            <div class="top-bar">
                <div class="activity-header">
                    <div class="activity-title" id="activityTitle">Activity</div>
                    <div class="activity-meta" id="activityMeta"></div>
                </div>

                <div style="display: flex; gap: 15px; align-items: center;">
                    <div id="filesDetected" class="files-detected hidden">
                        <span class="files-detected-label">Files:</span>
                        <div class="file-list" id="fileList"></div>
                    </div>

                    <div id="unitToggle" class="unit-toggle hidden">
                        <label>Units:</label>
                        <span class="unit-label">km</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="unitSwitch">
                            <span class="slider"></span>
                        </label>
                        <span class="unit-label">mi</span>
                    </div>
                </div>
            </div>

            <div class="description-card" id="descriptionCard" style="display:none;">
                <h3>Description</h3>
                <p id="activityDescription"></p>
                <div id="mediaThumbnails" class="media-thumbnails"></div>
            </div>

            <div id="mediaModal" class="modal">
                <button class="modal-close" onclick="closeModal()">&times;</button>
                <button class="modal-nav modal-prev" onclick="navigateMedia(-1)">&#10094;</button>
                <img id="modalImage" class="modal-content" src="" alt="">
                <button class="modal-nav modal-next" onclick="navigateMedia(1)">&#10095;</button>
            </div>

            <div class="stats-grid" id="statsGrid"></div>

            <div id="map"></div>

            <div class="charts-container">
                <div class="chart-card">
                    <h3>Elevation Profile</h3>
                    <div class="chart-wrapper">
                        <canvas id="elevationChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <h3>Heart Rate</h3>
                    <div class="chart-wrapper">
                        <canvas id="heartRateChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <h3>Pace</h3>
                    <div class="chart-wrapper">
                        <canvas id="paceChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let activityData = {
            fit: null,
            gpx: null,
            metadata: null,
            records: [],
            detectedFiles: []
        };

        let map = null;
        let polyline = null;
        let hoverMarker = null;
        let charts = {
            elevation: null,
            heartRate: null,
            pace: null
        };

        let useImperial = false; // false = km, true = mi
        let currentHoverIndex = null; // Shared hover index across all charts
        let mediaFiles = []; // Detected media files
        let currentMediaIndex = 0; // Current image in gallery

        // Conversion constants
        const KM_TO_MI = 0.621371;
        const M_TO_FT = 3.28084;

        // Custom Chart.js plugin for crosshair
        const crosshairPlugin = {
            id: 'crosshair',
            afterDatasetsDraw(chart, args, options) {
                if (currentHoverIndex === null) return;

                const { ctx, chartArea: { top, bottom, left, right }, scales: { x } } = chart;
                const meta = chart.getDatasetMeta(0);

                if (meta.data[currentHoverIndex]) {
                    const xPos = meta.data[currentHoverIndex].x;

                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(xPos, top);
                    ctx.lineTo(xPos, bottom);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        };

        // Register the plugin
        Chart.register(crosshairPlugin);

        // Auto-load on page load
        window.addEventListener('DOMContentLoaded', autoLoadActivity);

        // Unit toggle handler
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('unitSwitch').addEventListener('change', (e) => {
                useImperial = e.target.checked;
                if (activityData.summary) {
                    renderActivity();
                }
            });
        });

        async function autoLoadActivity() {
            const filesToTry = [
                { path: 'activity.fit', type: 'fit', name: 'activity.fit' },
                { path: 'activity.gpx', type: 'gpx', name: 'activity.gpx' },
                { path: 'metadata.yaml', type: 'metadata', name: 'metadata.yaml' },
                { path: 'metadata.yml', type: 'metadata', name: 'metadata.yml' },
                { path: 'metadata.org', type: 'metadata', name: 'metadata.org' }
            ];

            showStatus('Loading activity files...');

            try {
                // Try to load each file
                for (const file of filesToTry) {
                    try {
                        const response = await fetch(file.path);
                        if (response.ok) {
                            activityData.detectedFiles.push({
                                name: file.name,
                                path: file.path,
                                type: file.type
                            });

                            if (file.type === 'fit') {
                                showStatus('Parsing .fit file...');
                                const arrayBuffer = await response.arrayBuffer();
                                activityData.fit = await parseFitData(arrayBuffer);
                            } else if (file.type === 'gpx') {
                                showStatus('Parsing .gpx file...');
                                const text = await response.text();
                                activityData.gpx = parseGpxData(text);
                            } else if (file.type === 'metadata') {
                                showStatus('Loading metadata...');
                                const text = await response.text();
                                activityData.metadata = parseMetadata(text, file.path);
                            }
                        }
                    } catch (error) {
                        // File not found or error loading, continue
                        console.log(`Could not load ${file.path}:`, error.message);
                    }
                }

                // Show detected files
                if (activityData.detectedFiles.length > 0) {
                    showDetectedFiles();
                }

                // Try to detect media files
                await detectMediaFiles();

                // Check if we have any data (activity files or metadata)
                if (!activityData.fit && !activityData.gpx && !activityData.metadata) {
                    showError('No activity files or metadata found. Please ensure activity.fit, activity.gpx, or metadata.yaml exists in the same directory.');
                    return;
                }

                // Merge data from sources if we have GPS data
                if (activityData.fit || activityData.gpx) {
                    showStatus('Processing activity data...');
                    mergeActivityData();
                }

                // Render activity
                showStatus('Rendering activity...');
                renderActivity();

                hideStatus();
                document.getElementById('activityContent').classList.remove('hidden');
                if (activityData.fit || activityData.gpx) {
                    document.getElementById('unitToggle').classList.remove('hidden');
                }
            } catch (error) {
                console.error('Error loading activity:', error);
                showError('Error loading activity: ' + error.message);
                hideStatus();
            }
        }

        async function detectMediaFiles() {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
            const videoExtensions = ['.mp4', '.mov', '.avi', '.webm'];

            try {
                // Try to fetch the media directory listing
                const response = await fetch('media/');
                if (!response.ok) return;

                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const links = doc.querySelectorAll('a');

                mediaFiles = [];
                links.forEach(link => {
                    const href = link.getAttribute('href');
                    if (!href || href === '../') return;

                    const lower = href.toLowerCase();
                    const isImage = imageExtensions.some(ext => lower.endsWith(ext));
                    const isVideo = videoExtensions.some(ext => lower.endsWith(ext));

                    if (isImage || isVideo) {
                        mediaFiles.push({
                            path: 'media/' + href,
                            type: isImage ? 'image' : 'video',
                            name: href
                        });
                    }
                });

                if (mediaFiles.length > 0) {
                    renderMediaThumbnails();
                }
            } catch (error) {
                console.log('Could not detect media files:', error.message);
            }
        }

        function renderMediaThumbnails() {
            const container = document.getElementById('mediaThumbnails');
            container.innerHTML = '';

            mediaFiles.forEach((media, index) => {
                if (media.type === 'image') {
                    const img = document.createElement('img');
                    img.src = media.path;
                    img.className = 'media-thumbnail';
                    img.alt = media.name;
                    img.onclick = () => openModal(index);
                    container.appendChild(img);
                }
                // For videos, show first frame as thumbnail
                // TODO: Could generate proper video thumbnails
            });

            if (mediaFiles.length > 0) {
                document.getElementById('descriptionCard').style.display = 'block';
            }
        }

        function openModal(index) {
            currentMediaIndex = index;
            const media = mediaFiles[index];
            const modal = document.getElementById('mediaModal');
            const modalImg = document.getElementById('modalImage');

            if (media.type === 'image') {
                modalImg.src = media.path;
                modal.classList.add('active');
            }
        }

        function closeModal() {
            document.getElementById('mediaModal').classList.remove('active');
        }

        function navigateMedia(direction) {
            currentMediaIndex = (currentMediaIndex + direction + mediaFiles.length) % mediaFiles.length;
            const media = mediaFiles[currentMediaIndex];
            document.getElementById('modalImage').src = media.path;
        }

        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            } else if (e.key === 'ArrowLeft') {
                navigateMedia(-1);
            } else if (e.key === 'ArrowRight') {
                navigateMedia(1);
            }
        });

        function showDetectedFiles() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';

            activityData.detectedFiles.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';

                const icon = file.type === 'fit' ? 'üìä' : file.type === 'gpx' ? 'üó∫Ô∏è' : 'üìÑ';

                fileItem.innerHTML = `
                    <span class="file-icon">${icon}</span>
                    <a href="${file.path}" download="${file.name}">${file.name}</a>
                `;
                fileList.appendChild(fileItem);
            });

            document.getElementById('filesDetected').classList.remove('hidden');
        }

        async function parseFitData(arrayBuffer) {
            return new Promise((resolve, reject) => {
                try {
                    const fitParser = new FitParser({
                        force: true,
                        speedUnit: 'km/h',
                        lengthUnit: 'km',
                        temperatureUnit: 'celsius',
                        elapsedRecordField: true,
                        mode: 'both'
                    });

                    fitParser.parse(arrayBuffer, (error, data) => {
                        if (error) {
                            reject(error);
                        } else {
                            resolve(data);
                        }
                    });
                } catch (error) {
                    reject(error);
                }
            });
        }

        function parseGpxData(xmlString) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

                const trackPoints = xmlDoc.getElementsByTagName('trkpt');
                const points = [];

                for (let i = 0; i < trackPoints.length; i++) {
                    const pt = trackPoints[i];
                    const lat = parseFloat(pt.getAttribute('lat'));
                    const lon = parseFloat(pt.getAttribute('lon'));

                    const eleElement = pt.getElementsByTagName('ele')[0];
                    const timeElement = pt.getElementsByTagName('time')[0];
                    const hrElement = pt.getElementsByTagNameNS('*', 'hr')[0];

                    const point = {
                        latitude: lat,
                        longitude: lon,
                        elevation: eleElement ? parseFloat(eleElement.textContent) : null,
                        timestamp: timeElement ? new Date(timeElement.textContent) : null,
                        heartRate: hrElement ? parseInt(hrElement.textContent) : null
                    };

                    points.push(point);
                }

                return { points };
            } catch (error) {
                throw new Error('Failed to parse GPX: ' + error.message);
            }
        }

        function parseMetadata(content, filename) {
            try {
                if (filename.endsWith('.yaml') || filename.endsWith('.yml')) {
                    return jsyaml.load(content);
                } else if (filename.endsWith('.org')) {
                    return parseOrgFile(content);
                }
            } catch (error) {
                throw new Error('Failed to parse metadata: ' + error.message);
            }
        }

        function parseOrgFile(content) {
            // Simple org-mode parser
            const metadata = {};
            const lines = content.split('\n');
            let descriptionLines = [];
            let inDescription = false;

            for (const line of lines) {
                // Parse properties like #+PROPERTY: value
                const propMatch = line.match(/^#\+(\w+):\s*(.+)$/);
                if (propMatch) {
                    const key = propMatch[1].toLowerCase();
                    metadata[key] = propMatch[2].trim();
                    continue;
                }

                // Parse drawer properties like :KEY: value
                const drawerMatch = line.match(/^:(\w+):\s*(.+)$/);
                if (drawerMatch) {
                    const key = drawerMatch[1].toLowerCase();
                    metadata[key] = drawerMatch[2].trim();
                    continue;
                }

                // Collect description content (everything else that's not metadata)
                if (line.trim() && !line.startsWith('#') && !line.startsWith(':')) {
                    descriptionLines.push(line);
                }
            }

            if (descriptionLines.length > 0) {
                metadata.description = descriptionLines.join('\n');
            }

            return metadata;
        }

        function mergeActivityData() {
            // Prioritize FIT data, fall back to GPX
            if (activityData.fit && activityData.fit.records) {
                activityData.records = activityData.fit.records.map(record => ({
                    timestamp: record.timestamp,
                    latitude: record.position_lat,
                    longitude: record.position_long,
                    elevation: record.altitude || record.enhanced_altitude,
                    heartRate: record.heart_rate,
                    speed: record.speed || record.enhanced_speed,
                    cadence: record.cadence,
                    power: record.power,
                    temperature: record.temperature
                })).filter(r => r.latitude && r.longitude);
            } else if (activityData.gpx && activityData.gpx.points) {
                activityData.records = activityData.gpx.points;
            }

            // Calculate additional metrics
            calculateMetrics();
        }

        function calculateMetrics() {
            if (activityData.records.length === 0) return;

            const records = activityData.records;

            // Calculate distance and speed
            let totalDistance = 0;
            for (let i = 1; i < records.length; i++) {
                const dist = calculateDistance(
                    records[i-1].latitude, records[i-1].longitude,
                    records[i].latitude, records[i].longitude
                );
                totalDistance += dist;
                records[i].distance = totalDistance;

                // Calculate speed from distance and time if not available
                if (!records[i].speed && records[i].timestamp && records[i-1].timestamp) {
                    const timeDiff = (records[i].timestamp - records[i-1].timestamp) / 1000; // seconds
                    if (timeDiff > 0) {
                        // speed in km/h
                        records[i].speed = (dist / timeDiff) * 3600;
                    }
                }
            }
            records[0].distance = 0;

            // Calculate elevation gain/loss
            let elevationGain = 0;
            let elevationLoss = 0;
            for (let i = 1; i < records.length; i++) {
                if (records[i].elevation && records[i-1].elevation) {
                    const diff = records[i].elevation - records[i-1].elevation;
                    if (diff > 0) elevationGain += diff;
                    else elevationLoss += Math.abs(diff);
                }
            }

            // Calculate duration
            let duration = 0;
            if (records[0].timestamp && records[records.length - 1].timestamp) {
                duration = (records[records.length - 1].timestamp - records[0].timestamp) / 1000;
            }

            // Calculate average speed, heart rate, etc.
            const speeds = records.filter(r => r.speed && r.speed > 0).map(r => r.speed);
            const heartRates = records.filter(r => r.heartRate).map(r => r.heartRate);

            // Calculate average speed from total distance and duration as fallback
            let avgSpeed = 0;
            if (speeds.length > 0) {
                avgSpeed = average(speeds);
            } else if (totalDistance > 0 && duration > 0) {
                // km/h = (km / seconds) * 3600
                avgSpeed = (totalDistance / duration) * 3600;
            }

            activityData.summary = {
                distance: totalDistance,
                duration: duration,
                elevationGain: elevationGain,
                elevationLoss: elevationLoss,
                avgSpeed: avgSpeed,
                maxSpeed: speeds.length > 0 ? Math.max(...speeds) : 0,
                avgHeartRate: heartRates.length > 0 ? average(heartRates) : 0,
                maxHeartRate: heartRates.length > 0 ? Math.max(...heartRates) : 0,
                startTime: records[0].timestamp,
                endTime: records[records.length - 1].timestamp
            };
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula
            const R = 6371; // Earth's radius in km
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function toRad(degrees) {
            return degrees * Math.PI / 180;
        }

        function average(arr) {
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        }

        function renderActivity() {
            // Render header
            const title = activityData.metadata?.title ||
                          activityData.metadata?.name ||
                          'Activity';
            document.getElementById('activityTitle').textContent = title;

            // Handle date from metadata or GPS data
            let dateStr = '';
            if (activityData.metadata?.date) {
                const metaDate = new Date(activityData.metadata.date);
                dateStr = metaDate.toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            } else if (activityData.summary?.startTime) {
                dateStr = new Date(activityData.summary.startTime).toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            let metaStr = dateStr;
            if (activityData.metadata?.type) {
                metaStr += dateStr ? ' ‚Ä¢ ' + activityData.metadata.type : activityData.metadata.type;
            }
            document.getElementById('activityMeta').textContent = metaStr;

            // Render description
            if (activityData.metadata?.description) {
                document.getElementById('descriptionCard').style.display = 'block';
                document.getElementById('activityDescription').textContent = activityData.metadata.description;
            }

            // Only render GPS-based components if we have GPS data
            if (activityData.summary) {
                // Render stats
                renderStats();

                // Render map
                renderMap();

                // Render charts
                renderCharts();
            }
        }

        function renderStats() {
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = '';

            const summary = activityData.summary;

            // Convert units based on toggle
            const distance = useImperial ? summary.distance * KM_TO_MI : summary.distance;
            const elevationGain = useImperial ? summary.elevationGain * M_TO_FT : summary.elevationGain;
            const distanceUnit = useImperial ? 'mi' : 'km';
            const elevationUnit = useImperial ? 'ft' : 'm';
            const paceUnit = useImperial ? '/mi' : '/km';

            const stats = [
                {
                    label: 'Distance',
                    value: distance.toFixed(2),
                    unit: distanceUnit
                },
                {
                    label: 'Duration',
                    value: formatDuration(summary.duration),
                    unit: ''
                },
                {
                    label: 'Avg Pace',
                    value: formatPace(summary.avgSpeed, useImperial),
                    unit: paceUnit
                },
                {
                    label: 'Elevation Gain',
                    value: Math.round(elevationGain),
                    unit: elevationUnit
                },
                {
                    label: 'Avg Heart Rate',
                    value: Math.round(summary.avgHeartRate) || '--',
                    unit: 'bpm'
                },
                {
                    label: 'Max Heart Rate',
                    value: Math.round(summary.maxHeartRate) || '--',
                    unit: 'bpm'
                }
            ];

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-label">${stat.label}</div>
                    <div>
                        <span class="stat-value">${stat.value}</span>
                        <span class="stat-unit">${stat.unit}</span>
                    </div>
                `;
                statsGrid.appendChild(card);
            });
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);

            if (hours > 0) {
                return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }
            return `${minutes}:${String(secs).padStart(2, '0')}`;
        }

        function formatPace(speedKmh, imperial = false) {
            if (!speedKmh || speedKmh === 0) return '--';

            // Convert to appropriate unit
            let minPerUnit;
            if (imperial) {
                // Convert km/h to min/mi
                const speedMph = speedKmh * KM_TO_MI;
                minPerUnit = 60 / speedMph;
            } else {
                // min/km
                minPerUnit = 60 / speedKmh;
            }

            const minutes = Math.floor(minPerUnit);
            const seconds = Math.round((minPerUnit - minutes) * 60);
            return `${minutes}:${String(seconds).padStart(2, '0')}`;
        }

        function renderMap() {
            if (map) {
                map.remove();
            }

            // Initialize map
            map = L.map('map');

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            const coords = activityData.records.map(r => [r.latitude, r.longitude]);

            if (coords.length > 0) {
                polyline = L.polyline(coords, {
                    color: '#fc4c02',
                    weight: 3,
                    opacity: 0.8
                }).addTo(map);

                // Create custom start marker (green)
                const startIcon = L.divIcon({
                    className: 'custom-marker',
                    html: '<div style="background-color: #22c55e; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 12px;">S</div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });

                // Create custom finish marker (red)
                const finishIcon = L.divIcon({
                    className: 'custom-marker',
                    html: '<div style="background-color: #ef4444; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 12px;">F</div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });

                // Add start and finish markers
                L.marker(coords[0], { icon: startIcon }).addTo(map).bindPopup('Start');
                L.marker(coords[coords.length - 1], { icon: finishIcon }).addTo(map).bindPopup('Finish');

                // Force Leaflet to recalculate the map size first
                // Then fit bounds - this ensures proper zoom calculation
                setTimeout(() => {
                    map.invalidateSize();
                    map.fitBounds(polyline.getBounds(), {
                        padding: [50, 50],
                        maxZoom: 15  // Prevent zooming in too close
                    });
                }, 100);
            }
        }

        function updateMapHover(index) {
            if (!map || !activityData.records[index]) return;

            const record = activityData.records[index];
            const coords = [record.latitude, record.longitude];

            // Remove existing hover marker
            if (hoverMarker) {
                map.removeLayer(hoverMarker);
            }

            // Add new hover marker
            const hoverIcon = L.divIcon({
                className: 'hover-marker',
                html: '<div style="background-color: #3b82f6; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.4);"></div>',
                iconSize: [12, 12],
                iconAnchor: [6, 6]
            });

            hoverMarker = L.marker(coords, { icon: hoverIcon }).addTo(map);
        }

        function clearMapHover() {
            if (hoverMarker) {
                map.removeLayer(hoverMarker);
                hoverMarker = null;
            }
        }

        function updateAllCharts(index) {
            currentHoverIndex = index;

            // Update map
            if (index !== null) {
                updateMapHover(index);
            } else {
                clearMapHover();
            }

            // Trigger redraw on all charts
            if (charts.elevation) charts.elevation.update('none');
            if (charts.heartRate) charts.heartRate.update('none');
            if (charts.pace) charts.pace.update('none');
        }

        function renderCharts() {
            const records = activityData.records;

            // Prepare data with unit conversion
            const distances = records.map(r => {
                const dist = r.distance || 0;
                return useImperial ? dist * KM_TO_MI : dist;
            });
            const elevations = records.map(r => {
                const elev = r.elevation || 0;
                return useImperial ? elev * M_TO_FT : elev;
            });
            const heartRates = records.map(r => r.heartRate || null);
            const speeds = records.map(r => r.speed ? r.speed : null);

            const distanceUnit = useImperial ? 'mi' : 'km';
            const elevationUnit = useImperial ? 'ft' : 'm';
            const paceUnit = useImperial ? 'min/mi' : 'min/km';

            // Elevation chart
            if (charts.elevation) charts.elevation.destroy();
            const elevationCtx = document.getElementById('elevationChart').getContext('2d');
            charts.elevation = new Chart(elevationCtx, {
                type: 'line',
                data: {
                    labels: distances,
                    datasets: [{
                        label: `Elevation (${elevationUnit})`,
                        data: elevations,
                        borderColor: '#4bc0c0',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onHover: (event, activeElements) => {
                        if (activeElements.length > 0) {
                            updateAllCharts(activeElements[0].index);
                        } else {
                            updateAllCharts(null);
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: `Distance (${distanceUnit})` },
                            ticks: {
                                callback: function(value) {
                                    return distances[value]?.toFixed(1);
                                },
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            title: { display: true, text: `Elevation (${elevationUnit})` }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const distance = distances[index];
                                    return `Distance: ${distance.toFixed(2)} ${distanceUnit}`;
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return `Elevation: ${Math.round(value)} ${elevationUnit}`;
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            });

            // Heart rate chart
            if (charts.heartRate) charts.heartRate.destroy();
            const heartRateCtx = document.getElementById('heartRateChart').getContext('2d');
            charts.heartRate = new Chart(heartRateCtx, {
                type: 'line',
                data: {
                    labels: distances,
                    datasets: [{
                        label: 'Heart Rate (bpm)',
                        data: heartRates,
                        borderColor: '#ff6384',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onHover: (event, activeElements) => {
                        if (activeElements.length > 0) {
                            updateAllCharts(activeElements[0].index);
                        } else {
                            updateAllCharts(null);
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: `Distance (${distanceUnit})` },
                            ticks: {
                                callback: function(value) {
                                    return distances[value]?.toFixed(1);
                                },
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            title: { display: true, text: 'Heart Rate (bpm)' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const distance = distances[index];
                                    return `Distance: ${distance.toFixed(2)} ${distanceUnit}`;
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return value ? `Heart Rate: ${Math.round(value)} bpm` : '';
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            });

            // Pace chart (convert speed to pace)
            const paces = speeds.map(speed => {
                if (speed && speed > 0) {
                    if (useImperial) {
                        // Convert km/h to min/mi
                        const speedMph = speed * KM_TO_MI;
                        return 60 / speedMph;
                    } else {
                        // Convert km/h to min/km
                        return 60 / speed;
                    }
                }
                return null;
            });

            if (charts.pace) charts.pace.destroy();
            const paceCtx = document.getElementById('paceChart').getContext('2d');
            charts.pace = new Chart(paceCtx, {
                type: 'line',
                data: {
                    labels: distances,
                    datasets: [{
                        label: `Pace (${paceUnit})`,
                        data: paces,
                        borderColor: '#36a2eb',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onHover: (event, activeElements) => {
                        if (activeElements.length > 0) {
                            updateAllCharts(activeElements[0].index);
                        } else {
                            updateAllCharts(null);
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: `Distance (${distanceUnit})` },
                            ticks: {
                                callback: function(value) {
                                    return distances[value]?.toFixed(1);
                                },
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            title: { display: true, text: `Pace (${paceUnit})` },
                            reverse: true,  // Lower pace (faster) at top
                            ticks: {
                                callback: function(value) {
                                    const minutes = Math.floor(value);
                                    const seconds = Math.round((value - minutes) * 60);
                                    return `${minutes}:${String(seconds).padStart(2, '0')}`;
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const distance = distances[index];
                                    return `Distance: ${distance.toFixed(2)} ${distanceUnit}`;
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value) {
                                        const minutes = Math.floor(value);
                                        const seconds = Math.round((value - minutes) * 60);
                                        return `Pace: ${minutes}:${String(seconds).padStart(2, '0')} /${useImperial ? 'mi' : 'km'}`;
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            });
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
        }

        function hideError() {
            document.getElementById('error').classList.add('hidden');
        }

        function showStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function hideStatus() {
            document.getElementById('status').style.display = 'none';
        }
    </script>
</body>
</html>
